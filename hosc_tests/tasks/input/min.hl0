// Program Optimizations and Transformations in Calculation Form

list $a :: Nil | Cons $a (list $a);
boolean :: True | False;
number :: Z | S number;

// note that hd < isort (homeomorphic embedding!)

//hd z (isort lessOrEq xs) // this will be the minimal element
//min z xs lessOrEq
//case ((((insert lessOrEq) v8) ((isort lessOrEq) v9))) of {Nil  : (Z ); Cons v2 v3 : v2;}

//hd (isort lessOrEq (Cons x1 (Cons x2 xs)))

//hd (insert lessOrEq x (isort lessOrEq xs))

//hd x (isort lessOrEq xs)
//case ((((insert lessOrEq) v10) ((isort lessOrEq) v11))) of {Nil  : x; Cons v3 v4 : v3;}
//case (case ((((insert lessOrEq) v39) ((isort lessOrEq) v40))) of {Nil  : (Cons x (Nil )); Cons v9 v10 : case (((lessOrEq x) v9)) of {True  : (Cons x (Cons v9 v10)); False  : (Cons v9 (((insert lessOrEq) x) v10));};}) of {Nil  : (Z ); Cons v2 v3 : v2;}

case ((((insert lessOrEq) v102) ((isort lessOrEq) v103))) of {
	Nil  : x; 
	Cons v42 v43 : 
				case (((lessOrEq x) v42)) of {
					True  : x; 
					False  : hd ((((insert lessOrEq) v102) ((isort lessOrEq) v103)));
				}
}

where

hd = %x {%xs {
	case xs of {
		Nil: x;
		Cons x1 xs1: x1;
	}
}}

isort = %lessOrEq { %xs {
	case xs of {
		Nil: Nil;
		Cons x1 xs1: insert lessOrEq x1 (isort lessOrEq xs1);
	}
}}

insert = %lessOrEq{ %x{ %xs{
	case xs of {
		Nil: Cons x Nil;
		Cons x1 xs1:
			case lessOrEq x x1 of {
				True: Cons x (Cons x1 xs1);
				False: Cons x1 (insert lessOrEq x xs1); 
			};
	}
}}}

min = %z{ %xs{ %f{
    case xs of {
        Nil: z;
        Cons x1 xs1: case f x1 (min z xs1 f) of {True: x1; False: min z xs1 f; };
	}
}}} 