package hosc.sc1

import scala.util.parsing.input.StreamReader
import scala.util.parsing.input.CharArrayReader

import java.io.File
import java.io.FileInputStream
import java.io.InputStreamReader
import java.io.FileReader
import java.io.FileWriter
import java.io.BufferedReader

import HLanguage._
import HLanguage1._
import HParsers._
import Util._

import hosc.util.Canonizer.{canonize1 => can}

object SuperCompiler1SApp {
  val help = """usage: hosc.SuperCompiler1SApp -i input_file  -p program_output_file
  |Where:
  |input_file            path to input file where code is written HL1 language syntax
  |program_output_file   path to file where residual program will be placed
  |""".stripMargin
  def main(args : Array[String]) : Unit = {
    var fileName: String = null
    var outProgramFileName: String = null
    var sugared = false
    args.toList match {
      case "-i" :: input_file :: "-p" :: output_file_1 :: Nil =>
        fileName = input_file
        outProgramFileName = output_file_1
      case "-help" :: Nil => 
        println(help)
        return
      case _ => 
        throw new IllegalArgumentException("run spcs.SuperCompiler1App -help for help")       
    }
    
    val program1 = program1FromFile(fileName)
    val sc = new SuperCompiler1S(program1, new VarGen1())
    val resProgram:Program1 = sc.superCompile()    
    
    val doc = resProgram.toDoc
    val slFile = new java.io.File(outProgramFileName)
    if (!slFile.exists){
      slFile.createNewFile()
    }
    val fw = new FileWriter(slFile);
    fw.write("// generated by scp1 from " + fileName + "\n")
    doc.format(100, fw)
    fw.flush();
    fw.close(); 
  }
  
  def program1FromFile(fileName: String) = {
    val file = new File(fileName)
    val sb = new StringBuilder
    val in = new BufferedReader(new FileReader(fileName));
    var str: String = null
    do {
      str = in.readLine
      if (str != null){
        sb.append(str)
        sb.append("\n")
      }
    } while (str != null)
    in.close();
    val pr = HParsers1.parseProgram(new CharArrayReader(sb.toString.toCharArray))
    if (pr.successful) {
      val program = pr.get
      val canExpr = can(program.expr)      
      val canProgram = Program1(program.ts, canExpr)
      Postprocessor1.postprocess(canProgram)
      val elcExpr = LangUtils.hl1ToELC(canExpr)
      val typeInferrer = new TypeInferrer(canProgram.ts)
      typeInferrer.inferType(elcExpr)
      canProgram
    } else { 
      throw new IllegalArgumentException(pr.toString)
    }
  }
}